# rubikNN
Нейросеть для сборки кубика Рубика.

В данном проекте я обучил нейросеть собирать кубик Рубика. Для генерации датасета был написан код, который многократно разбирет кубик и запоминает последовательность движений.
После мы считываем задом-наперед пары - состояние кубика и ход, обратный тому, который привел к этому состоянию. Количество врщащений при очередном разборе случайно выбирается от 1 до 20, так как за 20 ходов кубик можно собрать из любого состояния. Состояние кубика представляется в виде тензора с использованием one-hot encoding. Так получаются обучающие данные.

После мы пропускаем обучающие данные через нейросеть. В нейрости чередуются линейные слои и функции активации reLU. Модель обучалась 

В качестве теста кубик разбирается (совершается 20 вращений), а затем модель последовательно ставит каждому состоянию в соответствие правильное движение. Такая процедура повторяется 1000 раз и на выходе получается процентное соотношение. 

Также можно ввести конфигурацию кубика и получить последовательность нужных ходов. Для этого нужно в файле test.py зафиксировать переменную solver_mode и указать конфигурацию.
Ниже вы можете видеть пример конфигурации и последовательности ходов.

{

"w": ["w-", "w-", "w-", "w-", "w-", "w-", "g-", "g-", "g-"],

"r": ["r-", "r-", "r-", "r-", "r-", "r-", "r-", "r-", "r-"],

"g": ["g-", "g-", "g-", "g-", "g-", "g-", "y-", "y-", "y-"],

"o": ["o-", "o-", "o-", "o-", "o-", "o-", "o-", "o-", "o-"],

"b": ["b-", "b-", "b-", "b-", "b-", "b-", "w-", "w-", "w-"],

"y": ["y-", "y-", "y-", "y-", "y-", "y-", "b-", "b-", "b-"]

}








